<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[数据库导出表结构及数据]]></title>
      <url>%2F2016%2F12%2F04%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%87%BA%E8%A1%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E6%95%B0%E6%8D%AE%2F</url>
      <content type="text"><![CDATA[Mysql导出表结构及表数据命令行下具体用法如下：1mysqldump -u用户名 -p密码 -d 数据库名 表名 脚本名; 1、导出数据库名为dbname的表结构(假设其中用户名为root,密码为123456,生成的脚本名为db.sql)1mysqldump -uroot -p123456 -d dbname &gt; db.sql; -p 后面的密码可以暂时省略，可在回车以后输入。 2、导出数据库dbname某张表(test)结构1mysqldump -uroot -p123456 -d dbname test &gt; db.sql; 3、导出数据库为dbname所有表结构及表数据（不加-d）1mysqldump -uroot -p123456 dbname &gt; db.sql; 4、导出数据库为dbname某张表(test)结构及表数据（不加-d）1mysqldump -uroot -p123456 dbname test &gt; db.sql;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[操作系统-存储管理]]></title>
      <url>%2F2016%2F11%2F15%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[实验目的： 观察系统存储器使用情况 观察进程使用存储器的情况 掌握通过内存映像文件提高性能的方法 掌握动态内存分配技术 存储相关的命令free 显示系统使用和未被使用的内存数量（可以实时执行）输出包含的标题有 3 行信息：Mem。此行包含了有关物理内存的信息。包括以下详细内容：total。该项显示可用的物理内存总量，单位为 KB。该数字小于安装的物理内存的容量，是因为内核本身也要使用一小部分的内存。used。该项显示了用于应用程序超速缓存数据的内存容量。free。该项显示了此时未使用且有效的内存容量。Shared/buffers/cached。这些列显示了有关内存如何使用的更为详细的信息。-/+ buffers/cache。Linux 系统中的部分内存用来为应用程序或设备高速缓存数据。这部分内存在需要用于其他目的时可以释放。free 列显示了调整的缓冲区行，显示释放缓冲区或高速缓存时可以使用的内存容量。Swap。该行显示有关交换内存利用率的信息。该信息包含全部、已使用和释放的可用内存容量。 vmstat 报告进程、内存、分页、IO等多类信息（使用手册页） size 列出目标文件段大小和总大小（使用手册页） /proc文件系统（使用手册页man 5 proc）/proc/meminfo 内存状态信息/proc/stat 包含内存页、内存对换等信息。/proc/pid/stat 某个进程的信息(包含内存使用信息)/proc/pid/maps某个进程的内存映射区信息，包括地址范围、权限、偏移量以及主次设备号和映射文件的索引节点。/proc/pid/statm 某个进程的内存使用信息，包括内存总大小、驻留集大小、共享页面数、文本页面数、堆栈页面数和脏页面数。 内存映像文件内存映像文件是指把一个磁盘文件映像到内存中，二者存在逐字节的对应关系。这样做可以加速I/O操作，并可以共享数据。 mmap（建立内存映射）表头文件 #include(unistd.h) #include(sys/mman.h) 定义函数 void mmap(void start,size_t length,int prot,int flags,int fd,off_t offsize);函数说明 mmap()用来将某个文件内容映射到内存中，对该内存区域的存取即是直接对该文件内容的读写。参数start指向欲对应的内存起始地址，通常设为NULL，代表让系统自动选定地址，对应成功后该地址会返回。参数length代表将文件中多大的部分对应到内存。参数 prot代表映射区域的保护方式有下列组合PROT_EXEC 映射区域可被执行PROT_READ 映射区域可被读取PROT_WRITE 映射区域可被写入PROT_NONE 映射区域不能存取参数 flags会影响映射区域的各种特性MAP_FIXED 如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此旗标。MAP_SHARED对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。MAP_PRIVATE 对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容。MAP_ANONYMOUS建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。MAP_DENYWRITE只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。MAP_LOCKED 将映射区域锁定住，这表示该区域不会被置换（swap）。在调用mmap()时必须要指定MAP_SHARED 或MAP_PRIVATE。参数fd为open()返回的文件描述词，代表欲映射到内存的文件。参数offset为文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。返回值 若映射成功则返回映射区的内存起始地址，否则返回MAP_FAILED(－1)，错误原因存于errno 中。错误代码 EBADF 参数fd 不是有效的文件描述词EACCES 存取权限有误。如果是MAP_PRIVATE 情况下文件必须可读，使用MAP_SHARED则要有PROT_WRITE以及该文件要能写入。EINVAL 参数start、length 或offset有一个不合法。EAGAIN 文件被锁住，或是有太多内存被锁住。ENOMEM 内存不足。 munmap（解除内存映射）表头文件 #include(unistd.h) #include(sys/mman.h) 定义函数 int munmap(void *start,size_t length);函数说明 munmap()用来取消参数start所指的映射内存起始地址，参数length则是欲取消的内存大小。当进程结束或利用exec相关函数来执行其他程序时，映射内存会自动解除，但关闭对应的文件描述词时不会解除映射。返回值 如果解除映射成功则返回0，否则返回－1，错误原因存于errno中错误代码EINVAL参数 start或length 不合法。 动态内存分配malloc（配置内存空间）表头文件 #include(stdlib.h) 定义函数 void * malloc(size_t size);函数说明 malloc()用来配置内存空间，其大小由指定的size决定。返回值 若配置成功则返回一指针，失败则返回NULL。 free（释放原先配置的内存）表头文件 #include(stdlib.h) 定义函数 void free(void *ptr);函数说明 参数ptr为指向先前由malloc()、calloc()或realloc()所返回的内存指针。调用free()后ptr所指的内存空间便会被收回。假若参数ptr所指的内存空间已被收回或是未知的内存地址，则调用free()可能会有无法预期的情况发生。若参数ptr为NULL，则free()不会有任何作用。 calloc（配置内存空间）表头文件 #include (stdlib.h) 定义函数 void calloc(size_t nmemb，size_t size);函数说明 calloc()用来配置nmemb个相邻的内存单位，每一单位的大小为size，并返回指向第一个元素的指针。这和使用下列的方式效果相同:malloc(nmembsize);不过，在利用calloc()配置内存时会将内存内容初始化为0。返回值 若配置成功则返回一指针，失败则返回NULL。 其他getpagesize（取得内存分页大小）表头文件 #include(unistd.h) 定义函数 size_t getpagesize(void);函数说明 返回一分页的大小，单位为字节（byte）。此为系统的分页大小，不一定会和硬件分页大小相同。返回值 内存分页大小。附加说明在Intel x86 上其返回值应为4096bytes。 实验要求:分别使用命令和/proc文件系统列出系统当前内存的使用情况。 启动几个耗时较长的后台进程（多个grep），分别使用free和vmstat连续实时观察内存的使用情况。通过后台运行多个”grep -r -i ‘a’ /“ 进程，观察内存的使用情况 用size工具观察三个不同的可执行文件的大小以及它们段的大小。 启动一个耗时较长的后台进程，通过/proc文件系统查看该进程所有内存使用相关信息，并列出。后台运行程序是：vmstat 3。通过ps af 命令查看此后台进程pid。再在/proc/$PID中查看此进程所有内存使用的相关信息。 编写一个程序，打印系统的页面大小。 阅读并编译运行以下程序，总结内存映象文件的使用方法。利用mmap()来读取/etc/passwd 文件内容1234567891011121314151617181920#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/mman.h&gt;int main() &#123; int fd; void *start; struct stat sb; fd=open("/etc/passwd",O_RDONLY); fstat(fd,&amp;sb); start=mmap(NULL,sb.st_size,PROT_READ,MAP_PRIVATE,fd,0); if(start= = MAP_FAILED) return; printf("%s",start); munmap(start,sb.st_size); closed(fd); return 0;&#125; 编写一个程序，利用内存映象文件，实现less工具的功能。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include&lt;stdio.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/mman.h&gt;#include&lt;string.h&gt;#include&lt;memory.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include &lt;termios.h&gt;int lastrow(char * s,int d);int nextrow(char * s,int d);int onepage(char * s,int d);int main()&#123; FILE *input; struct termios initial_settings, new_settings; int inputString; input = fopen("/dev/tty", "r"); //定位到终端输入 if(!input) &#123; fprintf(stderr, "Unable to open /dev/tty\n"); exit(1); &#125; tcgetattr(fileno(input), &amp;initial_settings); new_settings = initial_settings; new_settings.c_lflag &amp;= ~ICANON; new_settings.c_lflag &amp;= ~ECHO; new_settings.c_cc[VMIN] = 1; new_settings.c_cc[VTIME] = 0; new_settings.c_lflag &amp;= ~ISIG; if(tcsetattr(fileno(input), TCSANOW, &amp;new_settings) != 0) &#123; fprintf(stderr, "Could not set attributes\n"); &#125; int fd,play=0; char lab; char *start; struct stat sb; fd=open("test.txt",O_RDONLY); /*打开*/ fstat(fd,&amp;sb); /*获取文件大小*/ start=mmap(NULL,sb.st_size,PROT_READ,MAP_PRIVATE,fd,0); if(start==MAP_FAILED) /*判断是否映射成功*/ return(1); play=onepage(start,play)+1; lab=fgetc(input); while(lab!= 'q'&amp;&amp; lab!='Q') &#123; if(play&lt;40||play&gt;sb.st_size) &#123; lab = fgetc(input); break; &#125; else if(lab==' ') play=play+1+onepage(start,play); else if(lab=='D'||lab=='d') play=play+1+nextrow(start,play); else if(lab=='U'||lab=='u') play=1+lastrow(start,play); lab = fgetc(input); &#125; tcsetattr(fileno(input), TCSANOW, &amp;initial_settings); exit(0); munmap(start,sb.st_size); /*解除映射*/ close(fd); return 0;&#125;int onepage(char * s,int d)&#123; int i,count=0; char * buffer=malloc(2048);//配置内存空间，由buffer指向该空间 s+=d; /*每10行作为一页输出*/ for(i=0;i&lt;2048;i++) &#123; if(s[i]=='\n') count++; if(count==10) break; &#125; memcpy(buffer,s,i); buffer[i]='\0'; printf("%s\n",buffer); return i;&#125;int nextrow(char * s,int d) //输出下一行&#123; int i; char * buffer=malloc(100); s+=d; for(i=0;i&lt;100;i++) if(s[i]=='\n') break; memcpy(buffer,s,i); buffer[i]='\0'; printf("%s\n",buffer); return i;&#125;int lastrow(char * s,int d) //输出上一行&#123; int i,count=0; char * buffer=malloc(100); int py=d; for(;d&gt;0;d--) &#123; if(s[d]=='\n') count++; if(count==2) break; &#125; memcpy(buffer,s+d+1,py-d-2); buffer[py-d-2]='\0'; printf("%s\n",buffer); return d;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F11%2F09%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[操作系统实验-管道]]></title>
      <url>%2F2016%2F11%2F08%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C-%E7%AE%A1%E9%81%93%2F</url>
      <content type="text"><![CDATA[概念管道有两种类型：无名管道和有名管道。无名管道没有名字，也从来不在文件系统中出现，只是和内存中的一个索引节点相关联的两个文件描述符，该索引节点指向指向内存中的一个物理块。写进程向管道写入数据时，字节被复制到共享数据页面中，读进程从管道读出数据时，字节从共享页面中读出。无名管道是半双工的，数据只能在一个方向传送，而且只能在相关的、有共同祖先的的进程之间使用。有（命）名管道（FIFO）可以为两个不相关的进程提供通信。它不是临时对象，是文件系统中的一个实体，可以用mknod和mkfifo创建。在写进程使用之前，必须让读进程先打开管道，任何读进程从中读取之前必须有写进程向其写入数据。FIFO有一个路径与之关联，故无亲缘关系的进程可以访问同一个FIFO。 无名管道工作原理无名管道由单个进程创建，但很少在单个进程内使用。其典型用途是在一个父进程和子进程之间通信。首先由一个进程创建一个管道后调用fork派生一个自身的拷贝，如图1：然后，父进程关闭该管道的读出端，子进程关闭同一管道的写入端，这样就在父子进程间提供了一个单项数据流，如图2。当需要一个双向数据流时，必须建立两个管道，每个方向一个，实际步骤如下：1． 创建管道1（fd1[0]和fd1[1]）和管道2（fd2[0]和fd2[1]）2． fork()3． 父进程关闭管道1的读出端fd1[0]4． 父进程关闭管道2的写入端fd2[1]5． 子进程关闭管道1的写入端fd1[1]6． 子进程关闭管道2的读出端fd2[0]管道布局如图3：管道读写分别使用read和write系统调用，其中读取字节数不应大于PIPE_BUF(中定义，主要是为了保证原子操作)，因此通常定义缓冲区大小为PIPE_BUF。管道使用完后要关闭(close)。 基本命令$command1 | command2将command1的标准输出作为command2的标准输入。 mknod 创建块、字符或管道文件 mkfifo 创建一个命名管道(FIFO) 系统调用pipe（建立管道）表头文件: #include(unistd.h) 定义函数:int pipe(int filedes[2]);函数说明 pipe()会建立管道，并将文件描述词由参数filedes数组返回。filedes[0]为管道里的读取端，filedes[1]则为管道的写入端。返回值 若成功则返回零，否则返回-1，错误原因存于errno中。错误代码 EMFILE 进程已用完文件描述词最大量。ENFILE 系统已无文件描述词可用。EFAULT 参数filedes数组地址不合法。 mkfifo（建立具名管道）表头文件: #include(sys/types.h) #include(sys/stat.h) 定义函数:int mkfifo(const char * pathname,mode_t mode);函数说明 mkfifo()会依参数pathname建立特殊的FIFO文件，该文件必须不存在，而参数mode为该文件的权限（mode&amp;~umask），因此umask值也会影响到FIFO文件的权限。mkfifo()建立的FIFO文件其他进程都可以用读写一般文件的方式存取。当使用open()来打开FIFO文件时，O_NONBLOCK旗标会有影响1、当使用O_NONBLOCK 旗标时，打开FIFO 文件来读取的操作会立刻返回，但是若还没有其他进程打开FIFO 文件来读取，则写入的操作会返回ENXIO 错误代码。2、没有使用O_NONBLOCK 旗标时，打开FIFO 来读取的操作会等到其他进程打开FIFO文件来写入才正常返回。同样地，打开FIFO文件来写入的操作会等到其他进程打开FIFO 文件来读取后才正常返回。返回值 若成功则返回0，否则返回-1，错误原因存于errno中。错误代码 EACCESS 参数pathname所指定的目录路径无可执行的权限EEXIST 参数pathname所指定的文件已存在。ENAMETOOLONG 参数pathname的路径名称太长。ENOENT 参数pathname包含的目录不存在ENOSPC 文件系统的剩余空间不足ENOTDIR 参数pathname路径中的目录存在但却非真正的目录。EROFS 参数pathname指定的文件存在于只读文件系统内。 open（打开文件）表头文件: #include(sys/types.h) #include(sys/stat.h) #include(fcntl.h) 定义函数:int open( const char pathname, int flags);int open( const char pathname,int flags, mode_t mode);函数说明 参数pathname 指向欲打开的文件路径字符串。下列是参数flags 所能使用的旗标:O_RDONLY 以只读方式打开文件O_WRONLY 以只写方式打开文件O_RDWR 以可读写方式打开文件。上述三种旗标是互斥的，也就是不可同时使用，但可与下列的旗标利用OR(|)运算符组合。O_CREAT 若欲打开的文件不存在则自动建立该文件。O_EXCL 如果O_CREAT 也被设置，此指令会去检查文件是否存在。文件若不存在则建立该文件，否则将导致打开文件错误。此外，若O_CREAT与O_EXCL同时设置，并且欲打开的文件为符号连接，则会打开文件失败。返回值 若所有欲核查的权限都通过了检查则返回0 值，表示成功，只要有一个权限被禁止则返回-1。错误代码 EEXIST 参数pathname 所指的文件已存在，却使用了O_CREAT和O_EXCL旗标。EACCESS 参数pathname所指的文件不符合所要求测试的权限。EROFS 欲测试写入权限的文件存在于只读文件系统内。EFAULT 参数pathname指针超出可存取内存空间。EINVAL 参数mode 不正确。ENAMETOOLONG 参数pathname太长。ENOTDIR 参数pathname不是目录。ENOMEM 核心内存不足。ELOOP 参数pathname有过多符号连接问题。EIO I/O 存取错误。 close（关闭文件）表头文件: #include(unistd.h) 定义函数:int close(int fd);函数说明 当使用完文件后若已不再需要则可使用close()关闭该文件，二close()会让数据写回磁盘，并释放该文件所占用的资源。参数fd为先前由open()或creat()所返回的文件描述词。返回值 若文件顺利关闭则返回0，发生错误时返回-1。错误代码 EBADF 参数fd 非有效的文件描述词或该文件已关闭。 read（由已打开的文件读取数据）表头文件: #include(unistd.h) 定义函数:ssize_t read(int fd,void * buf ,size_t count);函数说明 read()会把参数fd 所指的文件传送count个字节到buf指针所指的内存中。若参数count为0，则read()不会有作用并返回0。返回值为实际读取到的字节数，如果返回0，表示已到达文件尾或是无可读取的数据，此外文件读写位置会随读取到的字节移动。错误代码 EINTR 此调用被信号所中断。EAGAIN 当使用不可阻断I/O 时（O_NONBLOCK），若无数据可读取则返回此值。EBADF 参数fd 非有效的文件描述词，或该文件已关闭。 write（将数据写入已打开的文件内）表头文件: #include(unistd.h) 定义函数:ssize_t write (int fd,const void * buf,size_t count);函数说明 write()会把参数buf所指的内存写入count个字节到参数fd所指的文件内。当然，文件读写位置也会随之移动。返回值 如果顺利write()会返回实际写入的字节数。当有错误发生时则返回-1，错误代码存入errno中。错误代码 EINTR 此调用被信号所中断。EAGAIN 当使用不可阻断I/O 时（O_NONBLOCK），若无数据可读取则返回此值。EADF 参数fd非有效的文件描述词，或该文件已关闭。 unlink（删除文件）表头文件: #include(unistd.h) 定义函数:int unlink(const char * pathname);函数说明 unlink()会删除参数pathname指定的文件。如果该文件名为最后连接点，但有其他进程打开了此文件，则在所有关于此文件的文件描述词皆关闭后才会删除。如果参数pathname为一符号连接，则此连接会被删除。返回值 成功则返回0，失败返回-1，错误原因存于errno错误代码 EROFS 文件存在于只读文件系统内EFAULT 参数pathname指针超出可存取内存空间ENAMETOOLONG 参数pathname太长ENOMEM 核心内存不足ELOOP 参数pathname 有过多符号连接问题EIO I/O 存取错误 标准库函数popen（建立管道I/O）表头文件: #include(stdio.h) 定义函数:FILE popen( const char command,const char type);函数说明 popen()会调用fork()产生子进程，然后从子进程中调用/bin/sh -c来执行参数command的指令。参数type可使用“r”代表读取，“w”代表写入。依照此type值，popen()会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中。此外，所有使用文件指针(FILE)操作的函数也都可以使用，除了fclose()以外。返回值 若成功则返回文件指针，否则返回NULL，错误原因存于errno中。错误代码 EINVAL参数type不合法。 pclose（关闭管道I/O）表头文件: #include(stdio.h) 定义函数:int pclose(FILE * stream);函数说明 pclose()用来关闭由popen所建立的管道及文件指针。参数stream为先前由popen()所返回的文件指针。返回值 返回子进程的结束状态。如果有错误则返回-1，错误原因存于errno中。错误代码 ECHILD pclose()无法取得子进程的结束状态。 实验题目第一题：阅读以下程序，编译并运行程序，分析程序执行过程和结果，注释程序主要语句。1234567891011121314151617181920212223#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int filedes[2]; char buffer[80]; if(pipe(filedes)&lt;0)&#123; printf("pipe error"); exit(1); &#125; if(fork()&gt;0)&#123; char s[ ] = "hello,chen!\n"; close(filedes[0]); write(filedes[1],s,sizeof(s)); close(filedes[1]); &#125;else&#123; close(filedes[1]); read(filedes[0],buffer,80); printf("%s",buffer); close(filedes[0]); &#125; return 0;&#125; 第二题：阅读以下程序，编译并运行程序，分析程序执行过程和结果，注释程序主要语句。12345678910111213141516171819202122#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;stdio.h&gt;#include&lt;fcntl.h&gt;main()&#123; char buffer[80]; int fd; unlink("FIFO"); mkfifo("FIFO",0666); if(fork()&gt;0)&#123; char s[ ]="hello,chen!\n"; fd = open("FIFO",O_WRONLY); write(fd,s,sizeof(s)); close(fd); &#125;else&#123; fd= open("FIFO",O_RDONLY); read(fd,buffer,80); printf("%s",buffer); close(fd); &#125;&#125; 第三题：阅读以下程序，编译并运行程序，分析程序执行过程和结果，注释程序主要语句。123456789101112131415#include&lt;stdio.h&gt;main() &#123; FILE * fp; char buffer[80]; fp = popen("cat /etc/passwd","r");/* 创建一个子进程，子进程执行cat /etc/passwd命令 popen()建立管道连接到子进程，并以读取的方式连接到 子进程的输出设备。返回一个文件指针给fp */ fgets(buffer,sizeof(buffer),fp); //从返回的文件指针中读取数据保存到buffer中 printf("%s",buffer); pclose(fp);&#125;&#125; 第四题：编写一个程序，读取一个数据文件，对每一个数据进行某种运算，再在屏幕输出计算结果。要求以上工作用两个进程实现，父进程负责读文件和显示，子进程进行计算，进程间通信使用无名管道。（使用系统调用）解答：程序中，父进程从一个文件中读取一个数组，并写到管道1中。然后等待子进程结束。子进程从管道1中读取一个数组，并对数组中每个元素进行a[i]=a[i]*i; 的操作，并将改变后的数据写入到管道2中，自此子进程结束。父进程等到子进程结束后，从管道2中读取数组并输出。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int filedes1[2],filedes2[2]; if(pipe(filedes1)&lt;0||pipe(filedes2)&lt;0) &#123; //创建两个管道 printf("pipe error"); exit(1); &#125; if(fork()&gt;0)&#123; FILE *fp; int b[10]; int i; if((fp=fopen("test.txt","r"))==NULL) &#123; printf("File cannot be opened/n"); exit(1); &#125; for (i=0; i&lt;10; i++) &#123; fscanf(fp,"%d", &amp;b[i]); printf("父进程从文件读数据：%d \n",b[i]); &#125; fclose(fp); close(filedes1[0]); //父进程关闭管道1的读出端 write(filedes1[1],b,sizeof(b)); //父进程通过管道1的写入端向管道中写入一个数组b，大小为数组的字节数（10*4）; close(filedes1[1]); //父进程关闭管道1的写入端 wait(0); //等待子进程结束 close(filedes2[1]); //父进程关闭管道2的写入端。 read(filedes2[0],b,40); //父进程从管道2中读出一个数组并保存到b中，此时b数组已发生改变，大小为数组的字节数 for( i=0;i&lt;10;i++) &#123; printf("父进程从管道读数据：%d \n",b[i]); &#125; close(filedes2[0]); //父进程关闭管道2的读出端 &#125; else &#123; //子进程，一下语句功能同父进程类似，不再赘述 int a[10]; int i; close(filedes1[1]); read(filedes1[0],a,40); close(filedes1[0]); for( i=0;i&lt;10;i++)&#123; a[i]=a[i]*i; //子进程对数据进行操作 &#125; close(filedes2[0]); write(filedes2[1],a,sizeof(a)); close(filedes2[1]); &#125;&#125; 第五题：编写两个程序，一个创建一个FIFO，并读管道，并显示在屏幕上，另一个每过一段时间向该管道写数据（进程PID）。运行多个写程序和一个读程序，观察运行结果。（使用系统调用）写进程：12345678910111213#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;main()&#123; int fd; char s[ ] = "hello world!\n"; fd = open ("FIFO",O_WRONLY); write(fd,s,sizeof(s)); close(fd);&#125; 读进程:12345678910111213141516171819#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;main()&#123; char buffer[80]; int fd; mkfifo("FIFO",0666); while(1)&#123; fd= open("FIFO",O_RDONLY); //以只读的方式打开名 //管道，通过返回值可以对管道进行读操作 read(fd,buffer,80); //从管道中读出数据保存到buff中 printf("%s",buffer); close(fd); //关闭fd与管道的联系 sleep(1); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[华为面试题－关灯]]></title>
      <url>%2F2016%2F10%2F27%2F%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8D%E5%85%B3%E7%81%AF%2F</url>
      <content type="text"><![CDATA[问题描述： 一条长廊里依次装有n(1 ≤ n ≤ 65535)盏电灯，从头到尾编号1~n。 每盏电灯由一个拉线开关控制。开始，电灯全部关着。 有n个学生从长廊穿过。第一个学生把号码凡是1的倍数的电灯的开关拉一下； 接着第二个学生把号码凡是2的倍数的电灯的开关拉一下； 接着第三个学生把号码凡是3的倍数的电灯的开关拉一下； 如此继续下去，最后第n个学生把号码凡是n的倍数的电灯的开关拉一下。 n个学生按此规定走完后，长廊里电灯有几盏亮着。注：电灯数和学生数一致。 1234567891011121314 public class Guan_deng &#123; public static void main(String[] args) &#123; int sum=0; for(int i=1;i&lt;=65535;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; if(j*j&gt;i) break; if(j*j==i) sum++; &#125; &#125; System.out.println(sum); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[接雨水]]></title>
      <url>%2F2016%2F10%2F25%2F%E6%8E%A5%E9%9B%A8%E6%B0%B4%2F</url>
      <content type="text"><![CDATA[接雨水问题描述：如上图所示，海拔分别为 [0,1,0,2,1,0,1,3,2,1,2,1], 返回 6。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Solution &#123; /** * @param heights: an array of integers * @return: a integer */ public int trapRainWater(int[] heights) &#123; int sum=0; int index=0; int k=0; int mintemp=0; for(int i=0;i&lt;heights.length-1;)&#123; if(heights[i]&lt;=heights[i+1])&#123; i++; continue; &#125; else&#123; index=find(heights,heights[i],i+1); if(index==0)&#123; break; &#125; k=i+1; mintemp=Math.min(heights[i],heights[index]); while(k&lt;index)&#123; sum+=mintemp-heights[k]; k++; &#125; i=index; &#125; &#125; return sum; &#125; public int find(int[] heights,int temp,int i)&#123; int max=0; int index=0; int k=i; int count=0; for(;i&lt;heights.length;i++)&#123; if(i+1&lt;heights.length&amp;&amp;heights[i]&gt;=heights[i+1])&#123; count++; &#125; if(heights[i]&gt;max)&#123; max=heights[i]; index=i; &#125; if(heights[i]&gt;=temp)&#123; return i; &#125; &#125; if(count==heights.length-k)&#123; return 0; &#125; return index; &#125;&#125; 运行时间：1635ms]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[背包问题]]></title>
      <url>%2F2016%2F10%2F23%2F%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[背包问题1问题描述：在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]。注意事项：你不可以将物品进行切割。 样例如果有4个物品[2, 3, 5, 7]如果背包的大小为11，可以选择[2, 3, 5]装入背包，最多可以装满10的空间。如果背包的大小为12，可以选择[2, 3, 7]装入背包，最多可以装满12的空间。函数需要返回最多能装满的空间大小。1234567891011121314151617181920public class Solution &#123; /** * @param m: An integer m denotes the size of a backpack * @param A: Given n items with size A[i] * @return: The maximum size */ public int backPack(int m, int[] A) &#123; return backpack(m,A,0); &#125; public int backpack(int m,int[] A,int i)&#123; int max=0; for(;i&lt;A.length;i++)&#123; if(A[i]&lt;m) max=Math.max(A[i]+backpack(m-A[i],A,i+1),max); else if(A[i]==m) return A[i]; &#125; return max; &#125;&#125; 背包问题2给出n个物品的体积A[i]和其价值V[i]，将他们装入一个大小为m的背包，最多能装入的总价值有多大？注意事项：A[i], V[i], n, m均为整数。你不能将物品进行切分。你所挑选的物品总体积需要小于等于给定的m。样例：对于物品体积[2, 3, 5, 7]和对应的价值[1, 5, 2, 4], 假设背包大小为10的话，最大能够装入的价值为9。123456789101112131415public class Solution &#123; /** * @param m: An integer m denotes the size of a backpack * @param A &amp; V: Given n items with size A[i] and value V[i] * @return: The maximum value */ public int backpack(int m,int[] A,int V[],int i)&#123; int max=0; for(;i&lt;A.length;i++)&#123; if(A[i]&lt;=m) max=Math.max(V[i]+backpack(m-A[i],A,V,i+1),max); &#125; return max; &#125;&#125; 由于递归花费的时间较长，所以本程序还需改进。递归虽好，但要善用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[岛屿的个数]]></title>
      <url>%2F2016%2F10%2F23%2F%E5%B2%9B%E5%B1%BF%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
      <content type="text"><![CDATA[岛屿的个数给一个01矩阵，求不同的岛屿的个数。0代表海，1代表岛，如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。 样例在矩阵：[ [1, 1, 0, 0, 0], [0, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0], [0, 0, 0, 0, 1]]中有 3 个岛.1234567891011121314151617181920212223242526272829303132public class Solution &#123; /** * @param grid a boolean 2D matrix * @return an integer */ public int numIslands(boolean[][] grid) &#123; int count=0; for(int i=0;i&lt;grid.length;i++)&#123; for(int j=0;j&lt;grid[i].length;j++)&#123; if(grid[i][j]==true)&#123; count++; change(grid,i,j); &#125; &#125; &#125; return count; &#125; public void change(boolean[][] grid,int i,int j)&#123; grid[i][j]=false; if(i&gt;0 &amp;&amp; grid[i-1][j]==true)&#123; change(grid,i-1,j); &#125; if(i&lt;grid.length-1&amp;&amp;grid[i+1][j]==true)&#123; change(grid,i+1,j); &#125; if(j&gt;0&amp;&amp;grid[i][j-1]==true)&#123; change(grid,i,j-1); &#125; if(j&lt;grid[i].length-1&amp;&amp;grid[i][j+1]==true)&#123; change(grid,i,j+1); &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[装最多水的容器]]></title>
      <url>%2F2016%2F10%2F23%2F%E8%A3%85%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
      <content type="text"><![CDATA[装最多水的容器给定 n 个非负整数 a1, a2, …, an, 每个数代表了坐标中的一个点 (i, ai)。画 n 条垂直线，使得 i 垂直线的两个端点分别为(i, ai)和(i, 0)。找到两条线，使得其与 x 轴共同构成一个容器，以容纳最多水。 123456789101112131415161718192021public class Solution &#123; /** * @param heights: an array of integers * @return: an integer */ public int maxArea(int[] heights) &#123; int maxtemp=0; int max=0; for(int i=0;i&lt;heights.length;i++)&#123; for(int j=heights.length-1;j&gt;i;j--)&#123; if(heights[j]&gt;heights[i]||heights[j]==heights[i])&#123; maxtemp=maxtemp&gt;(heights[i]*(j-i))?maxtemp:heights[i]*(j-i); break; &#125; maxtemp=maxtemp&gt;(heights[j]*(j-i))?maxtemp:heights[j]*(j-i); &#125; max=max&gt;maxtemp?max:maxtemp; &#125; return max; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[跳跃游戏]]></title>
      <url>%2F2016%2F10%2F23%2F%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%2F</url>
      <content type="text"><![CDATA[跳跃游戏1问题描述：给出一个非负整数数组，你最初定位在数组的第一个位置。数组中的每个元素代表你在那个位置可以跳跃的最大长度。判断你是否能到达数组的最后一个位置。 1234567891011121314151617181920212223public class Solution &#123; /** * @param A: A list of integers * @return: The boolean answer */ public boolean canJump(int[] A) &#123; for(int i=0;i&lt;A.length;)&#123; if(A[i]==0&amp;&amp;i!=A.length-1)&#123; return false; &#125; if(A[i]&gt;=A.length-i-1)&#123; return true; &#125; if(A[i]!=0&amp;&amp;A[i]&lt;A.length-i-1)&#123; while(A[i]&gt;1&amp;&amp;A[i+A[i]]==0)&#123; //防止不走的情况 A[i]--; &#125; i=i+A[i]; &#125; &#125; return true; &#125;&#125; 跳跃游戏2问题描述：给出一个非负整数数组，你最初定位在数组的第一个位置。数组中的每个元素代表你在那个位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。 样例给出数组A = [2,3,1,1,4]，最少到达数组最后一个位置的跳跃次数是2(从数组下标0跳一步到数组下标1，然后跳3步到数组的最后一个位置，一共跳跃2次)。1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; /** * @param A: A list of lists of integers * @return: An integer */ public int jump(int[] A) &#123; int count=0; int k=0; int temp=0; int max=0; for(int i=0;i&lt;A.length;)&#123; if(A[i]==0&amp;&amp;i!=A.length-1)&#123; return 0; &#125; if(A[i]&gt;=A.length-i-1)&#123; count++; break; &#125; if(A[i]!=0&amp;&amp;A[i]&lt;A.length-i-1)&#123; k=1; while(k&lt;=A[i])&#123; if(A[i+k]+k&gt;max)&#123; temp=k; max=A[i+k]+k; &#125; k++; &#125; i=i+temp; count++; &#125; &#125; return count; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数独]]></title>
      <url>%2F2016%2F10%2F13%2F%E6%95%B0%E7%8B%AC%2F</url>
      <content type="text"><![CDATA[数独求解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;stdio.h&gt;#define UNASSIGNED 0#define N 9 // NxN 的大小// 是否还有未放置的位置int FindUnassignedLocation(int grid[N][N], int *row, int *col);// 在位置 grid[row][col]处，是否可以放置numint isSafe(int grid[N][N], int row, int col, int num);int SolveSudoku(int grid[N][N]) // 回溯法求解&#123; int row, col; int *p1,*p2; p1=&amp;row; p2=&amp;col; if (FindUnassignedLocation(grid, p1, p2)==0)//都已经放置完，则返true return 1; // success! for (int num = 1; num &lt;= 9; num++) &#123; if (isSafe(grid, row, col, num)) &#123; grid[row][col] = num; // 放置棋子 if (SolveSudoku(grid)) // return, if success, yay! return 1; grid[row][col] = UNASSIGNED; // 失败, 设置为 未放置的 &amp; 再一次尝试 &#125; &#125; return 0;&#125;int FindUnassignedLocation(int grid[N][N], int *row, int *col)&#123; for (*row = 0; *row &lt; N; (*row)++) for (*col = 0; *col &lt; N; (*col)++) if (grid[*row][*col] == UNASSIGNED) return 1; return 0;&#125;int UsedInRow(int grid[N][N], int row, int num)&#123; for (int col = 0; col &lt; N; col++) if (grid[row][col] == num) return 1; return 0;&#125;int UsedInCol(int grid[N][N], int col, int num)&#123; for (int row = 0; row &lt; N; row++) if (grid[row][col] == num) return 1; return 0;&#125;int UsedInBox(int grid[N][N], int boxStartRow, int boxStartCol, int num)&#123; for (int row = 0; row &lt; 3; row++) for (int col = 0; col &lt; 3; col++) if (grid[row+boxStartRow][col+boxStartCol] == num) return 1; return 0;&#125;int isSafe(int grid[N][N], int row, int col, int num)&#123; return UsedInRow(grid, row, num)==0 &amp;&amp;UsedInCol(grid, col, num)==0 &amp;&amp;UsedInBox(grid, row - row%3 , col - col%3, num)==0;&#125;void printGrid(int grid[N][N])&#123; for (int row = 0; row &lt; N; row++) &#123; for (int col = 0; col &lt; N; col++) printf("%4d", grid[row][col]); printf("\n\n"); &#125;&#125;/* 测试 */int main()&#123; int grid[N][N] = &#123;&#123;3, 0, 6, 5, 0, 8, 4, 0, 0&#125;, &#123;5, 2, 0, 0, 0, 0, 0, 0, 0&#125;, &#123;0, 8, 7, 0, 0, 0, 0, 3, 1&#125;, &#123;0, 0, 3, 0, 1, 0, 0, 8, 0&#125;, &#123;9, 0, 0, 8, 6, 3, 0, 0, 5&#125;, &#123;0, 5, 0, 0, 9, 0, 6, 0, 0&#125;, &#123;1, 3, 0, 0, 0, 0, 2, 5, 0&#125;, &#123;0, 0, 0, 0, 0, 0, 0, 7, 4&#125;, &#123;0, 0, 5, 2, 0, 6, 3, 0, 0&#125;&#125;; if (SolveSudoku(grid)) printGrid(grid); else printf("No solution exists"); return 0;&#125; 运行结果截图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[N_QUEEN]]></title>
      <url>%2F2016%2F10%2F13%2FN-QUEEN%2F</url>
      <content type="text"><![CDATA[通过递归实现求解N皇后问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.Scanner;public class N_Queen &#123; private int n; private int[] val; public N_Queen(int n2) &#123; n=n2; val = new int[n2];&#125;/** * 确定r行已放置的皇后是否可以 * @param r:行号 */ public boolean isPlace(int r)&#123; boolean b = true; for(int i = 0; i &lt; r; i++)&#123; if(val[r]==val[i]||Math.abs(val[r]-val[i])==Math.abs(r-i))&#123; b = false; break; &#125; &#125; return b; &#125; /** * 递归法实现N皇后问题,确定每一行皇后放置位置 * @param r：行号,从0到n-1 */ public void traceBackQueen(int r) &#123; if (r == n) &#123; print(); &#125;else &#123; for (int i = 0; i &lt; n; i++) &#123; val[r] = i; if (isPlace(r)) &#123; traceBackQueen(r+1); &#125; &#125; &#125; &#125; /** * 打印结果 */ public void print()&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (j == val[i]) &#123; System.out.print("1"+" "); continue; &#125; System.out.print("0"+" "); &#125; System.out.println(); &#125; System.out.println(); &#125; /* * test */ public static void main(String[] args)&#123; @SuppressWarnings("resource") Scanner input = new Scanner(System.in); System.out.println("请输入皇后的数量:"); int n = input.nextInt(); N_Queen queen = new N_Queen(n); queen.traceBackQueen(0); &#125; &#125; 运行结果截图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的生活]]></title>
      <url>%2F2016%2F10%2F13%2F%E6%88%91%E7%9A%84%E7%94%9F%E6%B4%BB%2F</url>
      <content type="text"><![CDATA[我的生活]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Operating]]></title>
      <url>%2F2016%2F10%2F13%2FOperating%2F</url>
      <content type="text"><![CDATA[操作系统进程管理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java Programing]]></title>
      <url>%2F2016%2F10%2F12%2FMy-new-article%2F</url>
      <content type="text"><![CDATA[二叉树遍历 12345678910111213141516171819202122232425262728293031323334import java.util.Scanner;public class Solution &#123;public static void main(String[] args) &#123; TreeNode root=null; root=CreatBinaryTree(); inorderTraversal(root);&#125;public static TreeNode CreatBinaryTree()&#123; TreeNode t=null; @SuppressWarnings("resource") Scanner scaner = new Scanner(System.in); String s = scaner.next(); char c = s.charAt(0); int val=c-'0'; if(c!='#') &#123; t=new TreeNode(val); t.left=CreatBinaryTree(); t.right=CreatBinaryTree(); &#125; return t;&#125;public static void inorderTraversal(TreeNode root) &#123; // write your code here if(root!=null) &#123; inorderTraversal(root.left); System.out.print(root.val+" "); inorderTraversal(root.right); &#125; &#125; &#125; 国庆节小动画程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148import java.awt.*;import java.awt.event.*;import java.util.*;import javax.swing.*;public class GuoqingStart extends JFrame &#123; Guoqing gq; public static void main(String[] args) &#123; new GuoqingStart(); &#125; public GuoqingStart() &#123; gq=new Guoqing(); this.addMouseListener(gq); this.add(gq); new Thread(gq).start(); this.setTitle("国庆快乐"); this.setLocation(100, 0); this.setSize(1000,700); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); this.setVisible(true); &#125;&#125;class Guoqing extends JPanel implements MouseListener,Runnable&#123; Bullet bullet; Vector&lt;Bullet&gt; bullets; static Vector&lt;Piece&gt; pieces; int times=1; public Guoqing() &#123; bullets=new Vector&lt;Bullet&gt;(); pieces=new Vector&lt;Piece&gt;(); &#125; public void paint(Graphics g) &#123; super.paint(g); times++; g.setColor(Color.black); g.fillRect(0, 0, 2000, 1000); g.setColor(Color.lightGray); for(int i=0;i&lt;this.bullets.size();i++)&#123; Bullet b=this.bullets.get(i); if(b.isLive)&#123; b.move(); g.fillOval(b.x,b.oldY, 15, 15); &#125; &#125; for(int i=0;i&lt;this.pieces.size();i++)&#123; Piece b=this.pieces.get(i); if(b.isLive)&#123; if(b.color==0)&#123; g.setColor(Color.red); &#125;else if(b.color==1)&#123; g.setColor(Color.blue); &#125;else if(b.color==2)&#123; g.setColor(Color.cyan); &#125;else if(b.color==3)&#123; g.setColor(Color.green); &#125;else&#123; g.setColor(Color.gray); &#125; if(times%2==0)&#123; b.move(); &#125; g.fillOval((int)b.x, (int)b.y, (int)b.w, (int)b.h); &#125; &#125; &#125; public void mousePressed(MouseEvent e) &#123; bullet=new Bullet(e.getX(),e.getY()); this.bullets.add(bullet); &#125; public void mouseClicked(MouseEvent e) &#123;&#125; public void mouseReleased(MouseEvent e) &#123;&#125; public void mouseEntered(MouseEvent e) &#123;&#125; public void mouseExited(MouseEvent e) &#123;&#125; @Override public void run() &#123; while(true)&#123; this.repaint(); try &#123; Thread.sleep(10); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class Piece&#123; double x,y; double w=15; double h=15; double velocityX, velocityY; boolean isLive=true; int color=0; int times=1; public Piece(double x,double y,double velocity,double angle,int color) &#123; this.x=x; this.y=y; this.color=color; velocityX = velocity * Math.cos(angle); velocityY = velocity * Math.sin(angle); &#125; public void move()&#123; velocityX *= 0.75; velocityY += 1.0; velocityY *= 0.75; y += velocityY; x += velocityX; times++; if(times%7==0)&#123; this.w-=2; this.h-=2; if(this.w&lt;=4)&#123; Guoqing.pieces.remove(this); &#125; &#125; &#125;&#125;class Bullet&#123; int x; int y; int oldY=700; boolean isLive=true; Piece piece; Random r=new Random(System.currentTimeMillis()); public Bullet(int x, int y) &#123; this.x = x; this.y = y; &#125; public void move()&#123; oldY-=8; if(oldY&lt;=y)&#123; this.isLive=false; int color=r.nextInt(4); for(int i=0;i&lt;200;i++)&#123; double angleXy = r.nextDouble() * 2 * Math.PI; double angleZ = r.nextDouble() * 2 * Math.PI; double velocity = 72 * Math.cos(angleZ); piece=new Piece(x,oldY,velocity, angleXy,color); Guoqing.pieces.add(piece); &#125; &#125; &#125; &#125;]]></content>
    </entry>

    
  
  
</search>
